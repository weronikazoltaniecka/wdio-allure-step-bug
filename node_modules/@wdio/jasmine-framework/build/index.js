import url from 'node:url';
import Jasmine from 'jasmine';
import logger from '@wdio/logger';
import { wrapGlobalTestMethod, executeHooksWithArgs } from '@wdio/utils';
import { matchers, getConfig } from 'expect-webdriverio';
import { _setGlobal } from '@wdio/globals';
import JasmineReporter from './reporter.js';
import { jestResultToJasmine } from './utils.js';
const INTERFACES = {
    bdd: ['beforeAll', 'beforeEach', 'it', 'xit', 'fit', 'afterEach', 'afterAll']
};
const TEST_INTERFACES = ['it', 'fit', 'xit'];
const NOOP = function noop() { };
const DEFAULT_TIMEOUT_INTERVAL = 60000;
const FILE_PROTOCOL = 'file://';
const log = logger('@wdio/jasmine-framework');
/**
 * Jasmine runner
 */
class JasmineAdapter {
    _cid;
    _config;
    _specs;
    _capabilities;
    _jasmineOpts;
    _reporter;
    _totalTests = 0;
    _hasTests = true;
    _lastTest;
    _lastSpec;
    _jrunner = new Jasmine({});
    constructor(_cid, _config, _specs, _capabilities, reporter) {
        this._cid = _cid;
        this._config = _config;
        this._specs = _specs;
        this._capabilities = _capabilities;
        this._jasmineOpts = Object.assign({
            cleanStack: true
        }, (this._config.jasmineOpts ||
            // @ts-expect-error legacy option
            this._config.jasmineNodeOpts));
        this._reporter = new JasmineReporter(reporter, {
            cid: this._cid,
            specs: this._specs,
            cleanStack: this._jasmineOpts.cleanStack,
            jasmineOpts: this._jasmineOpts
        });
        this._hasTests = true;
        this._jrunner.exitOnCompletion = false;
    }
    async init() {
        const self = this;
        const { jasmine } = this._jrunner;
        // @ts-ignore outdated
        const jasmineEnv = jasmine.getEnv();
        this._specs.forEach((spec) => this._jrunner.addSpecFile(
        /**
         * as Jasmine doesn't support file:// formats yet we have to
         * remove it before adding it to Jasmine
         */
        spec.startsWith(FILE_PROTOCOL)
            ? url.fileURLToPath(spec)
            : spec));
        // @ts-ignore only way to hack timeout into jasmine
        jasmine.DEFAULT_TIMEOUT_INTERVAL = this._jasmineOpts.defaultTimeoutInterval || DEFAULT_TIMEOUT_INTERVAL;
        jasmineEnv.addReporter(this._reporter);
        /**
         * Filter specs to run based on jasmineOpts.grep and jasmineOpts.invert
         */
        jasmineEnv.configure({
            specFilter: this._jasmineOpts.specFilter || this.customSpecFilter.bind(this),
            stopOnSpecFailure: Boolean(this._jasmineOpts.stopOnSpecFailure),
            failSpecWithNoExpectations: Boolean(this._jasmineOpts.failSpecWithNoExpectations),
            failFast: this._jasmineOpts.failFast,
            random: Boolean(this._jasmineOpts.random),
            seed: Boolean(this._jasmineOpts.seed),
            oneFailurePerSpec: Boolean(
            // depcrecated old property
            this._jasmineOpts.stopSpecOnExpectationFailure ||
                this._jasmineOpts.oneFailurePerSpec)
        });
        /**
         * enable expectHandler
         */
        jasmine.Spec.prototype.addExpectationResult = this.getExpectationResultHandler(jasmine);
        const hookArgsFn = (context) => [{ ...(self._lastTest || {}) }, context];
        const emitHookEvent = (fnName, eventType) => (_test, _context, { error } = {}) => {
            const title = `"${fnName === 'beforeAll' ? 'before' : 'after'} all" hook`;
            const hook = {
                id: '',
                start: new Date(),
                type: 'hook',
                description: title,
                fullName: title,
                duration: null,
                properties: {},
                passedExpectations: [],
                pendingReason: '',
                failedExpectations: [],
                deprecationWarnings: [],
                status: '',
                debugLogs: null,
                ...(error ? { error } : {})
            };
            this._reporter.emit('hook:' + eventType, hook);
        };
        /**
         * wrap commands
         */
        INTERFACES.bdd.forEach((fnName) => {
            const isTest = TEST_INTERFACES.includes(fnName);
            const beforeHook = [...this._config.beforeHook];
            const afterHook = [...this._config.afterHook];
            /**
             * add beforeAll and afterAll hooks to reporter
             */
            if (fnName.includes('All')) {
                beforeHook.push(emitHookEvent(fnName, 'start'));
                afterHook.push(emitHookEvent(fnName, 'end'));
            }
            wrapGlobalTestMethod(isTest, isTest ? this._config.beforeTest : beforeHook, hookArgsFn, isTest ? this._config.afterTest : afterHook, hookArgsFn, fnName, this._cid);
        });
        /**
         * for a clean stdout we need to avoid that Jasmine initialises the
         * default reporter
         */
        Jasmine.prototype.configureDefaultReporter = NOOP;
        /**
         * wrap Suite and Spec prototypes to get access to their data
         */
        // @ts-ignore
        const beforeAllMock = jasmine.Suite.prototype.beforeAll;
        // @ts-ignore
        jasmine.Suite.prototype.beforeAll = function (...args) {
            self._lastSpec = this.result;
            beforeAllMock.apply(this, args);
        };
        const executeMock = jasmine.Spec.prototype.execute;
        jasmine.Spec.prototype.execute = function (...args) {
            self._lastTest = this.result;
            // @ts-ignore overwrite existing type
            self._lastTest.start = new Date().getTime();
            executeMock.apply(this, args);
        };
        /**
         * set up WebdriverIO matchers with Jasmine
         */
        const expect = jasmineEnv.expectAsync;
        const matchers = this.#setupMatchers(jasmine);
        jasmineEnv.beforeAll(() => jasmineEnv.addAsyncMatchers(matchers));
        _setGlobal('expect', expect, this._config.injectGlobals);
        /**
         * load environment
         */
        await this._loadFiles();
        /**
         * overwrite Jasmine global expect with WebdriverIOs expect
         */
        _setGlobal('expect', expect, this._config.injectGlobals);
        return this;
    }
    async _loadFiles() {
        try {
            if (Array.isArray(this._jasmineOpts.requires)) {
                // @ts-ignore outdated types
                this._jrunner.addRequires(this._jasmineOpts.requires);
            }
            if (Array.isArray(this._jasmineOpts.helpers)) {
                this._jrunner.addMatchingHelperFiles(this._jasmineOpts.helpers);
            }
            // @ts-ignore outdated types
            await this._jrunner.loadRequires();
            await this._jrunner.loadHelpers();
            await this._jrunner.loadSpecs();
            // @ts-ignore outdated types
            this._grep(this._jrunner.env.topSuite());
            this._hasTests = this._totalTests > 0;
        }
        catch (err) {
            log.warn('Unable to load spec files quite likely because they rely on `browser` object that is not fully initialised.\n' +
                '`browser` object has only `capabilities` and some flags like `isMobile`.\n' +
                'Helper files that use other `browser` commands have to be moved to `before` hook.\n' +
                `Spec file(s): ${this._specs.join(',')}\n`, 'Error: ', err);
        }
    }
    _grep(suite) {
        // @ts-ignore outdated types
        suite.children.forEach((child) => {
            if (Array.isArray(child.children)) {
                return this._grep(child);
            }
            if (this.customSpecFilter(child)) {
                this._totalTests++;
            }
        });
    }
    hasTests() {
        return this._hasTests;
    }
    async run() {
        // @ts-expect-error
        this._jrunner.env.beforeAll(this.wrapHook('beforeSuite'));
        // @ts-expect-error
        this._jrunner.env.afterAll(this.wrapHook('afterSuite'));
        await this._jrunner.execute();
        const result = this._reporter.getFailedCount();
        await executeHooksWithArgs('after', this._config.after, [result, this._capabilities, this._specs]);
        return result;
    }
    customSpecFilter(spec) {
        const { grep, invertGrep } = this._jasmineOpts;
        const grepMatch = !grep || spec.getFullName().match(new RegExp(grep)) !== null;
        if (grepMatch === Boolean(invertGrep)) {
            // @ts-expect-error internal method
            if (typeof spec.pend === 'function') {
                // @ts-expect-error internal method
                spec.pend('grep');
            }
            return false;
        }
        return true;
    }
    /**
     * Hooks which are added as true Jasmine hooks need to call done() to notify async
     */
    wrapHook(hookName) {
        return () => executeHooksWithArgs(hookName, this._config[hookName], [this.prepareMessage(hookName)]).catch((e) => {
            log.info(`Error in ${hookName} hook: ${e.stack?.slice(7)}`);
        });
    }
    prepareMessage(hookName) {
        const params = { type: hookName };
        switch (hookName) {
            case 'beforeSuite':
            case 'afterSuite':
                params.payload = Object.assign({
                    file: this._jrunner?.specFiles[0]
                }, this._lastSpec);
                break;
            case 'beforeTest':
            case 'afterTest':
                params.payload = Object.assign({
                    file: this._jrunner?.specFiles[0]
                }, this._lastTest);
                break;
        }
        return this.formatMessage(params);
    }
    formatMessage(params) {
        const message = {
            type: params.type
        };
        if (params.payload) {
            message.title = params.payload.description;
            message.fullName = params.payload.fullName || null;
            message.file = params.payload.file;
            if (params.payload.failedExpectations && params.payload.failedExpectations.length) {
                message.errors = params.payload.failedExpectations;
                message.error = params.payload.failedExpectations[0];
            }
            if (params.payload.id && params.payload.id.startsWith('spec')) {
                message.parent = this._lastSpec?.description;
                message.passed = params.payload.failedExpectations.length === 0;
            }
            if (params.type === 'afterTest') {
                message.duration = new Date().getTime() - params.payload.start;
            }
            if (typeof params.payload.duration === 'number') {
                message.duration = params.payload.duration;
            }
        }
        return message;
    }
    getExpectationResultHandler(jasmine) {
        const { expectationResultHandler } = this._jasmineOpts;
        const origHandler = jasmine.Spec.prototype.addExpectationResult;
        if (typeof expectationResultHandler !== 'function') {
            return origHandler;
        }
        return this.expectationResultHandler(origHandler);
    }
    expectationResultHandler(origHandler) {
        const { expectationResultHandler } = this._jasmineOpts;
        return function (passed, data) {
            try {
                expectationResultHandler.call(this, passed, data);
            }
            catch (e) {
                /**
                 * propagate expectationResultHandler error if actual assertion passed
                 * but the custom handler decides to throw
                 */
                if (passed) {
                    passed = false;
                    data = {
                        passed,
                        message: 'expectationResultHandlerError: ' + e.message,
                        error: e
                    };
                }
            }
            return origHandler.call(this, passed, data);
        };
    }
    #transformMatchers(matchers) {
        return Object.entries(matchers).reduce((prev, [name, fn]) => {
            prev[name] = (util) => ({
                compare: async (actual, expected, ...args) => fn(util).compare(actual, expected, ...args),
                negativeCompare: async (actual, expected, ...args) => {
                    const { pass, message } = fn(util).compare(actual, expected, ...args);
                    return {
                        pass: !pass,
                        message
                    };
                }
            });
            return prev;
        }, {});
    }
    #setupMatchers(jasmine) {
        /**
         * overwrite "jasmine.addMatchers" to be always async since the `expect` global we
         * have is the `expectAsync` from Jasmine, so we need to ensure that synchronous
         * matchers are added to `expectAsync`
         */
        globalThis.jasmine.addMatchers = (matchers) => globalThis.jasmine.addAsyncMatchers(this.#transformMatchers(matchers));
        // @ts-expect-error not exported in jasmine
        const syncMatchers = this.#transformMatchers(jasmine.matchers);
        const wdioMatchers = Object.entries(matchers).reduce((prev, [name, fn]) => {
            prev[name] = () => ({
                async compare(...args) {
                    const context = getConfig();
                    const result = fn.apply({ ...context, isNot: false }, args);
                    return jestResultToJasmine(result, false);
                },
                async negativeCompare(...args) {
                    const context = getConfig();
                    const result = fn.apply({ ...context, isNot: true }, args);
                    return jestResultToJasmine(result, true);
                }
            });
            return prev;
        }, {});
        return { ...wdioMatchers, ...syncMatchers };
    }
}
const adapterFactory = {};
adapterFactory.init = async function (...args) {
    // @ts-ignore pass along parameters
    const adapter = new JasmineAdapter(...args);
    const instance = await adapter.init();
    return instance;
};
export default adapterFactory;
export { JasmineAdapter, adapterFactory };
export * from './types.js';
